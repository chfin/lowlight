<!DOCTYPE html>
<html lang=en>
 <head>
  <meta charset=UTF-8>
  <title>lowlight.lisp</title> 
  <link rel=stylesheet href=example.css> 
 </head>
 <body>
  <pre>
<code><span class="comment">;;;; lowlight.lisp</span>

(<span class="stdmacro">in-package</span> <span class="symbol">#:lowlight.1</span>)

(<span class="define">defun</span> <span class="defname">read-into-string</span> (<span class="symbol">in-stream</span> <span class="lambda">&amp;key</span> (<span class="symbol">buffer-size</span> <span class="number">4096</span>))
  <span class="string">"=&gt; a string containing the whole stream data from `in-stream`
Taken from Alexandria's `read-file-into-string.`"</span>
  (<span class="specialop">let</span> ((<span class="global">*print-pretty*</span> <span class="symbol">nil</span>))
    (<span class="withmacro">with-output-to-string</span> (<span class="symbol">datum</span>)
      (<span class="specialop">let</span> ((<span class="symbol">buffer</span> (<span class="stdfun">make-array</span> <span class="symbol">buffer-size</span> <span class="keyword">:element-type</span> <span class="quote">'</span><span class="stdfun">character</span>)))
	(<span class="stdmacro">loop</span>
	   <span class="keyword">:for</span> <span class="symbol">bytes-read</span> <span class="stdfun">=</span> (<span class="stdfun">read-sequence</span> <span class="symbol">buffer</span> <span class="symbol">in-stream</span>)
	   <span class="keyword">:do</span> (<span class="stdfun">write-sequence</span> <span class="symbol">buffer</span> <span class="symbol">datum</span> <span class="keyword">:start</span> <span class="number">0</span> <span class="keyword">:end</span> <span class="symbol">bytes-read</span>)
	   <span class="keyword">:while</span> (<span class="stdfun">=</span> <span class="symbol">bytes-read</span> <span class="symbol">buffer-size</span>))))))

(<span class="define">defun</span> <span class="defname">make-blocks-regex</span> (<span class="symbol">blocks</span>)
  (<span class="stdfun">format</span> <span class="symbol">nil</span> <span class="string">"```(~{~(~a~)~^|~})[\\n\\l]{1,2}([\\S\\s]*?)```"</span> <span class="symbol">blocks</span>))

(<span class="define">defun</span> <span class="defname">light-blocks%*</span> (<span class="symbol">style</span> <span class="symbol">input</span> <span class="symbol">output</span> <span class="symbol">blocks</span>)
  (<span class="withmacro">with-input-from-string</span> (<span class="symbol">pre</span> <span class="string">"```"</span>)
    (<span class="withmacro">with-input-from-string</span> (<span class="symbol">post</span> (<span class="stdfun">format</span> <span class="symbol">nil</span> <span class="string">"```~(~a~)"</span> (<span class="stdfun">car</span> <span class="symbol">blocks</span>)))
      (<span class="specialop">let*</span> ((<span class="stdfun">stream</span> (<span class="stdfun">make-concatenated-stream</span> <span class="symbol">pre</span> <span class="symbol">input</span> <span class="symbol">post</span>))
	     (<span class="symbol">lexer</span> (<span class="stdfun">make-instance</span> <span class="quote">'</span><span class="symbol">graylex:lexer-input-stream</span>
				   <span class="keyword">:stream</span> <span class="stdfun">stream</span>
				   <span class="keyword">:rules</span> (<span class="stdfun">cons</span> (<span class="symbol">make-blocks-rule</span> <span class="symbol">blocks</span>)
						(<span class="symbol">style-rules</span> (<span class="symbol">get-style</span> <span class="symbol">style</span>))))))
	(<span class="symbol">tokenize</span> <span class="symbol">lexer</span> <span class="symbol">output</span>)))))

(<span class="define">defun</span> <span class="defname">light</span> (<span class="symbol">style</span> <span class="symbol">input</span> <span class="lambda">&amp;optional</span> <span class="symbol">output</span>)
  <span class="string">"=&gt; a highlighted string or `t`
Highlights `input` which can be either a stream or a string.
The used style is given by `style`.
If `output` (a stream) is given, the result is printed on it,
otherwise the result is returned as a string."</span>
  (<span class="stdmacro">cond</span>
    ((<span class="stdfun">stringp</span> <span class="symbol">input</span>)
     (<span class="withmacro">with-input-from-string</span> (<span class="stdfun">stream</span> <span class="symbol">input</span>) (<span class="symbol">light</span> <span class="symbol">style</span> <span class="stdfun">stream</span> <span class="symbol">output</span>)))
    ((<span class="stdfun">not</span> <span class="symbol">output</span>)
     (<span class="withmacro">with-output-to-string</span> (<span class="symbol">out</span>) (<span class="symbol">light</span> <span class="symbol">style</span> <span class="symbol">input</span> <span class="symbol">out</span>)))
    (<span class="stdfun">t</span> (<span class="symbol">process-style</span> (<span class="symbol">get-style</span> <span class="symbol">style</span>) <span class="symbol">input</span> <span class="symbol">output</span>)
       <span class="stdfun">t</span>)))

(<span class="define">defun</span> <span class="defname">light-blocks%</span> (<span class="symbol">style</span> <span class="symbol">input</span> <span class="symbol">output</span> <span class="symbol">blocks</span>)
  <span class="string">"highlight all blocks in input"</span>
  (<span class="stdfun">princ</span> (<span class="symbol">ppcre:regex-replace-all</span> (<span class="symbol">make-blocks-regex</span> <span class="symbol">blocks</span>) <span class="symbol">input</span>
				  (<span class="stdmacro">lambda</span> (<span class="symbol">match</span> <span class="symbol">r1</span> <span class="symbol">r2</span> <span class="lambda">&amp;rest</span> <span class="stdfun">rest</span>)
				    (<span class="stdfun">declare</span> (<span class="stdfun">ignore</span> <span class="symbol">match</span> <span class="stdfun">rest</span>))
				    (<span class="stdfun">format</span> <span class="symbol">nil</span>
					    <span class="string">"&lt;pre&gt;&lt;code class=\"~(~a~) ~(~a~)\"&gt;~a&lt;/code&gt;&lt;/pre&gt;"</span>
					    <span class="symbol">style</span> <span class="symbol">r1</span> (<span class="symbol">light</span> <span class="symbol">style</span> <span class="symbol">r2</span>)))
				  <span class="keyword">:simple-calls</span> <span class="stdfun">t</span>)
	 <span class="symbol">output</span>))

(<span class="define">defun</span> <span class="defname">light-blocks</span> (<span class="symbol">style</span> <span class="symbol">input</span> <span class="lambda">&amp;key</span> <span class="symbol">output</span> (<span class="symbol">blocks</span> (<span class="symbol">style-name</span> <span class="symbol">style</span>)))
  <span class="string">"=&gt; a highlighted string or `t`
Highlights all markdown code blocks in `input` with `style`
and writes the result to `output` (or returns the result as a string,
if `output` is not given).

`light-blocks` only hightlights blocks starting with a language name from `blocks`
which defaults to the name of `style`. So if you are using the style `:common-lisp`
and want to highlight blocks starting with ` ```common-lisp`, then you may leave out
`blocks`. If you want blocks starting with ` ```cl` to be highlighted as well,
use `'(:common-lisp :cl)` for `blocks`."</span>
  (<span class="stdmacro">cond</span>
    ((<span class="stdfun">streamp</span> <span class="symbol">input</span>)
     (<span class="symbol">light-blocks</span> <span class="symbol">style</span> (<span class="symbol">read-into-string</span> <span class="symbol">input</span>) <span class="keyword">:output</span> <span class="symbol">output</span> <span class="keyword">:blocks</span> <span class="symbol">blocks</span>))
    ((<span class="stdfun">not</span> <span class="symbol">output</span>)
     (<span class="withmacro">with-output-to-string</span> (<span class="symbol">out</span>)
       (<span class="symbol">light-blocks</span> <span class="symbol">style</span> <span class="symbol">input</span> <span class="keyword">:output</span> <span class="symbol">out</span> <span class="keyword">:blocks</span> <span class="symbol">blocks</span>)))
    (<span class="stdfun">t</span> (<span class="symbol">light-blocks%</span> <span class="symbol">style</span> <span class="symbol">input</span> <span class="symbol">output</span> (<span class="specialop">if</span> (<span class="stdfun">listp</span> <span class="symbol">blocks</span>) <span class="symbol">blocks</span> (<span class="stdfun">list</span> <span class="symbol">blocks</span>)))
       <span class="stdfun">t</span>)))

(<span class="define">defun</span> <span class="defname">light-file</span> (<span class="symbol">style</span> <span class="symbol">in</span> <span class="lambda">&amp;key</span> <span class="symbol">out</span> <span class="symbol">css</span> <span class="symbol">title</span> <span class="symbol">raw</span>)
  <span class="string">"=&gt; `t`
Highlights the file given by `in`.
The used style is denoted by `style`.
If given, the result is written to the file `out`,
otherwise `in` is used, with the file ending replaced by html.
If given, `css` is used as the href parameter to a css relation
and `title` is used as the page title.
If `raw` is `t` the highlighted code is *not* wrapped into a html skeleton."</span>
  (<span class="stdmacro">unless</span> <span class="symbol">out</span> (<span class="setf">setf</span> <span class="symbol">out</span> (<span class="stdfun">make-pathname</span> <span class="keyword">:type</span> <span class="string">"html"</span> <span class="keyword">:defaults</span> <span class="symbol">in</span>)))
  (<span class="withmacro">with-open-file</span> (<span class="symbol">spinneret:*html*</span> <span class="symbol">out</span> <span class="keyword">:direction</span> <span class="keyword">:output</span> <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span>)
    (<span class="specialop">if</span> <span class="symbol">raw</span>
	(<span class="withmacro">with-open-file</span> (<span class="symbol">in-strm</span> <span class="symbol">in</span>)
	  (<span class="symbol">light</span> <span class="symbol">style</span> <span class="symbol">in-strm</span> <span class="symbol">out-strm</span>))
	(<span class="symbol">spinneret:with-html</span>
	  (<span class="keyword">:doctype</span>)
	  (<span class="keyword">:html</span> (<span class="keyword">:head</span> (<span class="keyword">:title</span> (<span class="stdmacro">or</span> <span class="symbol">title</span> (<span class="stdfun">file-namestring</span> <span class="symbol">in</span>)))
			  (<span class="stdmacro">when</span> <span class="symbol">css</span> (<span class="keyword">:link</span> <span class="keyword">:rel</span> <span class="string">"stylesheet"</span> <span class="keyword">:href</span> <span class="symbol">css</span>)))
		 (<span class="keyword">:body</span>
		  (<span class="keyword">:pre</span> (<span class="keyword">:code</span> (<span class="stdmacro">prog1</span> <span class="symbol">nil</span>
				 (<span class="withmacro">with-open-file</span> (<span class="symbol">in-strm</span> <span class="symbol">in</span>)
				   (<span class="symbol">light</span> <span class="symbol">style</span> <span class="symbol">in-strm</span> <span class="symbol">spinneret:*html*</span>))))))))))
  <span class="stdfun">t</span>)

(<span class="define">defun</span> <span class="defname">light-file-blocks</span> (<span class="symbol">style</span> <span class="symbol">in</span> <span class="lambda">&amp;key</span> <span class="symbol">out</span> (<span class="symbol">blocks</span> (<span class="symbol">style-name</span> <span class="symbol">style</span>)))
  <span class="string">"=&gt; `t`
Highlights a file with `light-blocks`.
`in` denotes the input file, if `out` is given, it denotes the output file.
If not, `in` is used, with the file extension replaced by `.html`,
so `foo.lisp` becomes `foo.html`. 
Be careful with files already ending on `.html` as they will not change."</span>
  (<span class="stdmacro">unless</span> <span class="symbol">out</span> (<span class="setf">setf</span> <span class="symbol">out</span> (<span class="stdfun">make-pathname</span> <span class="keyword">:type</span> <span class="string">"html"</span> <span class="keyword">:defaults</span> <span class="symbol">in</span>)))
  (<span class="withmacro">with-open-file</span> (<span class="symbol">out-strm</span> <span class="symbol">out</span> <span class="keyword">:direction</span> <span class="keyword">:output</span> <span class="keyword">:if-exists</span> <span class="keyword">:supersede</span>)
    (<span class="withmacro">with-open-file</span> (<span class="symbol">in-strm</span> <span class="symbol">in</span>)
      (<span class="symbol">light-blocks</span> <span class="symbol">style</span> <span class="symbol">in-strm</span> <span class="keyword">:output</span> <span class="symbol">out-strm</span> <span class="keyword">:blocks</span> <span class="symbol">blocks</span>))))

<span class="comment">;;; a simple language</span>
(<span class="define">define-simple-style</span> <span class="defname">:test-lang</span>
  (<span class="string">"\\\"[\\s\\S]*?\\\""</span> <span class="keyword">:string</span>)
  (<span class="string">"/\\*[\\s\\S]*?\\*/"</span> <span class="keyword">:comment</span>)
  (<span class="string">"\\d*"</span> <span class="keyword">:number</span>)
  (<span class="string">"\\w*"</span> <span class="keyword">:word</span>)
  (<span class="string">"\\s*"</span> <span class="keyword">:default</span>))
   </code>
  </pre>
 </body> 
</html>